#!/usr/bin/env python
'''
This node gets tf transforms for april tags
'''

import time
import random

import rospy
import tf
import numpy as np
from geometry_msgs.msg import Pose2D
from sawyer.msg import RelativeMove, State

class april_tags:
    def __init__(self):
        '''
        Initialise topics and some parameters used in the algorithm.
        '''
        self.listener = tf.TransformListener()

        # The list of all april tags
        # self.target_frame = 'target'
        # self.ee_frame = 'ee'
        # self.block_frames_list = ['block1','block2', 'block3', 'block4', 'block5']

    def get_transform_between_frames(self, reference_frame, target_frame):
        time_out = 0.3
        start_time = time.time()
        while(True):
            try:
                translation_vector, rotation_quaternions = self.listener.lookupTransform(
                                                      reference_frame,
                                                      target_frame,
                                                      rospy.Time(0))
                break
            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                if((time.time()- start_time) > time_out):
                    return None
        return translation_vector

    def get_tranforms(self):
        target_transform = self.get_transform_between_frames( 'target','block2')
        ee_transform = self.get_transform_between_frames('target','ee')
        rospy.loginfo("Target tf: %s", target_transform)
        rospy.loginfo("EE tf: %s", ee_transform)

        state = State()
        state.dx_targetToArm = ee_transform[0]
        state.dy_targetToArm= ee_transform[1]
        state.dx_targetToBlock = target_transform[0]
        state.dy_targetToBlock = target_transform[1]

        # state
        rospy.loginfo("State: \n%s", state)

        # reward
        arm_to_block = -((state.dx_targetToArm-state.dx_targetToBlock)**2+
                        (state.dy_targetToArm-state.dy_targetToBlock)**2)*100

        block_to_target = -(state.dx_targetToBlock**2+state.dy_targetToBlock**2)*100

        rospy.loginfo("Reward: \narm_to_block distance: %s \nblock_to_target distance: %s", arm_to_block,block_to_target)

        return state

def main():
    rospy.init_node('computer_vision')
    aprilTags = april_tags()
    state = aprilTags.get_tranforms()
    # rospy.spin()

if __name__=='__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
