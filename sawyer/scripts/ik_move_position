#! /usr/bin/env python

# based on Rethink Robotics go_to_cartesian_pose.py
# Copyright (c) 2016-2018, Rethink Robotics Inc.

"""
Move the robot arm to the new position relative to the prior position specified
in the topic /puck/relative_move.

Call using:
$ rosrun sawyer ik_move

Publish position commmands using:
$ rostopic pub /puck/pose sawyer/Move "dx: 0.1
dy: 0.
linear_speed: 0.5"
"""
import rospy
from geometry_msgs.msg import (
    PoseStamped,
    Pose,
    Point,
    Quaternion,
)
from std_msgs.msg import Header
from sensor_msgs.msg import JointState

from intera_core_msgs.srv import (
    SolvePositionIK,
    SolvePositionIKRequest,
)
from intera_core_msgs.msg import JointCommand

from sawyer.msg import RelativeMove
import PyKDL # for relative pose movements...
from tf_conversions import posemath # for relative pose movements...
from intera_interface import Limb


class go_to_pose(object):
    def __init__(self):
        # set up ik solver
        self.limb = "right"
        self.ns = "ExternalTools/" + self.limb + "/PositionKinematicsNode/IKService"
        self.iksvc = rospy.ServiceProxy(self.ns, SolvePositionIK)
        self.use_advanced_options = False

        # Set up sawyer
        self.limb = Limb()
        self.limb.set_joint_position_speed(speed=0.2)

        self.in_tip_frame = False
        self.tip_name = 'right_hand'
        self.endpoint_state = self.limb.tip_state(self.tip_name)
        if self.endpoint_state is None:
            rospy.logerr('Endpoint state not found with tip name %s', self.tip_name)
            return None

        # setup ros
        rospy.Subscriber('/puck/relative_move',RelativeMove,self.pose_callback)

    def pose_callback(self,data):
        ikreq = SolvePositionIKRequest()

        # get current state
        pose = self.endpoint_state.pose

        # relative move
        # create kdl frame from relative pose
        rot = PyKDL.Rotation.RPY(0.0, # roll
                                 0.0, # pitch
                                 0.0) # yaw
        trans = PyKDL.Vector(data.dx,
                             data.dy,
                             0.0) # dz

        f2 = PyKDL.Frame(rot, trans)
        # and convert the result back to a pose message
        if self.in_tip_frame:
          # end effector frame
          pose = posemath.toMsg(posemath.fromMsg(pose) * f2)
        else:
          # base frame
          pose = posemath.toMsg(f2 * posemath.fromMsg(pose))

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        self.limb.set_joint_position_speed(speed=data.linear_speed)

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        try:
            rospy.wait_for_service(self.ns, 5.0)
            resp = self.iksvc(ikreq)

            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                # seed_str = {
                #             ikreq.SEED_USER: 'User Provided Seed',
                #             ikreq.SEED_CURRENT: 'Current Joint Angles',
                #             ikreq.SEED_NS_MAP: 'Nullspace Setpoints',
                #            }.get(resp.result_type[0], 'None')
                # rospy.loginfo("SUCCESS - Valid Joint Solution Found from Seed Type: %s" %
                #       (seed_str,))
                # Format solution into Limb API-compatible dictionary
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("SUCCESS - Valid Joint Solution Found ")
                # rospy.loginfo("\nIK Joint Solution:\n%s", limb_joints)
                # rospy.loginfo("------------------")
                # rospy.loginfo("Response Message:\n%s", resp)

                # move
                self.limb.set_joint_positions(limb_joints)

            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])
        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

def main():
    rospy.init_node('ik_move')
    my_pose = go_to_pose()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
