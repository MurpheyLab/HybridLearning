#! /usr/bin/env python

# based on Rethink Robotics go_to_cartesian_pose.py
# Copyright (c) 2016-2018, Rethink Robotics Inc.

"""
Move the robot arm to the new position relative to the prior position specified
in the topic /puck/relative_move.

Call using:
$ rosrun sawyer ik_move

Publish position commmands using:
$ rostopic pub /puck/pose sawyer/RelativeMove "dx: 0.1
dy: 0."
"""
# general
import numpy as np
import time
from copy import copy, deepcopy
import warnings

# ros
import rospy
from geometry_msgs.msg import PoseStamped, Pose, Quaternion
from std_msgs.msg import Header, Float64
from sensor_msgs.msg import JointState
from std_srvs.srv import Trigger, TriggerResponse
from tf_conversions import transformations # , posemath # for relative pose movements...

# sawyer
from intera_core_msgs.srv import SolvePositionIK, SolvePositionIKRequest
from intera_core_msgs.msg import JointCommand, EndpointState,EndpointStates
from sawyer.msg import RelativeMove
# from intera_interface import Limb
from intera_interface import RobotParams

# pykdl
from sawyer_pykdl import sawyer_kinematics

class go_to_pose(object):
    def __init__(self):
        # set up ik solver
        limb = "right"
        self.tip_name = "right_hand"
        ns = "ExternalTools/" + limb + "/PositionKinematicsNode/IKService"
        self.iksvc = rospy.ServiceProxy(ns, SolvePositionIK)
        rospy.wait_for_service(ns, 5.0)

        # set up sawyer
        ns_cmd = '/robot/limb/' + limb + '/'
        params = RobotParams()
        self.joint_names = params.get_joint_names(limb)
        self._joint_angle = dict()
        self._joint_velocity = dict()
        self._joint_effort = dict()
        self._joint_names = self.joint_names
        self._tip_states = None

        # setup ros
        rospy.Service('/puck/reset', Trigger, self.reset)
        rospy.Subscriber('/puck/relative_move',RelativeMove,self.pose_callback)
        self.reset_sawyer_env = rospy.ServiceProxy('/puck/done', Trigger)
        self._pub_speed_ratio = rospy.Publisher(ns_cmd + 'set_speed_ratio', Float64, latch=True, queue_size=1)
        self._command_msg = JointCommand()
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            self._pub_joint_cmd = rospy.Publisher(ns_cmd + 'joint_command',JointCommand,tcp_nodelay=True,queue_size=1)
        self._pub_joint_cmd_timeout = rospy.Publisher(ns_cmd + 'joint_command_timeout',Float64,latch=True,queue_size=1)
        _joint_state_sub = rospy.Subscriber('robot/joint_states',JointState,self._on_joint_states,queue_size=1) #,tcp_nodelay=True)
        _tip_states_sub = rospy.Subscriber(ns_cmd + 'tip_states',EndpointStates,self._on_tip_states,queue_size=1) #,tcp_nodelay=True)

        # set up controller
        self.c = 0.5
        self.alpha = 0.7 # [0,1]
        self.reset_theta = dict()
        for name in self.joint_names:
            self.reset_theta[name] = 0.0
        self.delta_theta = copy(self.reset_theta)

        # initalize with current joint angles
        home_orientation = Quaternion(0, 1, 0, 0)
        quaternion = (home_orientation.x, home_orientation.y,
                      home_orientation.z, home_orientation.w)
        self.euler = transformations.euler_from_quaternion(quaternion)
        self.reset_arm = False

        # define home configuration
        home_pose = [-0.2, -0.6, 0.0, 1.9, 0.0, 0.3, 1.571];
        self.home_joints = dict(zip(self.joint_names, home_pose))
        self._pub_speed_ratio.publish(Float64(0.6))
        self.set_joint_positions(copy(self.home_joints))

        self.got_joints = False
        while (self.got_joints == False):
            # print('waiting')
            time.sleep(0.2)
        self.desired_theta = self.joint_angles()
        self.update_velocities()

    '''
    from limb class
    '''
    def _on_joint_states(self, msg):
        self.got_joints = True
        for idx, name in enumerate(msg.name):
            if name in self._joint_names:
                self._joint_angle[name] = msg.position[idx]
                self._joint_velocity[name] = msg.velocity[idx]
                self._joint_effort[name] = msg.effort[idx]

    def joint_angles(self):
        return deepcopy(self._joint_angle)

    def _on_tip_states(self, msg):
        self._tip_states = deepcopy(msg)

    def tip_state(self, tip_name):
        try:
            return deepcopy(self._tip_states.states[self._tip_states.names.index(tip_name)])
        except ValueError:
            return None

    def set_joint_positions(self, positions):
        self._command_msg.names = positions.keys()
        self._command_msg.position = positions.values()
        self._command_msg.mode = JointCommand.POSITION_MODE
        self._command_msg.header.stamp = rospy.Time.now()
        self._pub_joint_cmd.publish(self._command_msg)

    def set_joint_velocities(self, velocities):
        self._command_msg.names = velocities.keys()
        self._command_msg.velocity = velocities.values()
        self._command_msg.mode = JointCommand.VELOCITY_MODE
        self._command_msg.header.stamp = rospy.Time.now()
        self._pub_joint_cmd.publish(self._command_msg)

    def set_joint_torques(self, torques):
        self._command_msg.names = torques.keys()
        self._command_msg.effort = torques.values()
        self._command_msg.mode = JointCommand.TORQUE_MODE
        self._command_msg.header.stamp = rospy.Time.now()
        self._pub_joint_cmd.publish(self._command_msg)

    '''
    custom
    '''

    def normalize_angle(self, angle):
        if (angle > np.pi/2):
            angle -= np.pi
        elif (angle < -np.pi/2):
            angle += np.pi
        angle_new = np.clip(angle,-np.pi/4,np.pi/4)  # keep april tags in view
        return angle_new

    def pose_callback(self,data):
        # print(data)
        # solve inverse kinematics
        ikreq = SolvePositionIKRequest()

        current_pose = self.tip_state(self.tip_name).pose # get current state
        rospy.loginfo("Current Pose:\n%s", current_pose)

        # relative move
        theta = np.arctan2(copy(data.dy), copy(data.dx))
        theta = self.normalize_angle(copy(theta)) # limit angles to +/- pi/2 for april tag visibility

        orientation = Quaternion(*transformations.quaternion_from_euler(self.euler[0], self.euler[1], self.euler[2]+theta))
        # orientation = Quaternion(*transformations.quaternion_from_euler(self.euler[0], self.euler[1], self.euler[2]+data.dtheta))

        pose = current_pose
        pose.orientation =  orientation
        pose.position.x += data.dx
        pose.position.y += data.dy
        dz = np.clip(pose.position.z, 0.035,0.05)  # correct for drift
        pose.position.z = dz
        # rospy.loginfo("Updated Pose:\n%s", pose)

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        try:
            resp = self.iksvc(ikreq)
            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("Response Message:\n%s", resp)
                self.desired_theta = limb_joints
            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])
                resp = self.reset_sawyer_env()

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

    def pose_callback(self,data):
        # solve inverse kinematics
        ikreq = SolvePositionIKRequest()

        current_pose = self.tip_state(self.tip_name).pose # get current state
        rospy.loginfo("Current Pose:\n%s", current_pose)

        # relative move
        theta = np.arctan2(copy(data.dy), copy(data.dx))
        theta = self.normalize_angle(copy(theta)) # limit angles to +/- pi/2 for april tag visibility

        orientation = Quaternion(*transformations.quaternion_from_euler(self.euler[0], self.euler[1], self.euler[2]+theta))
        # orientation = Quaternion(*transformations.quaternion_from_euler(self.euler[0], self.euler[1], self.euler[2]+data.dtheta))

        pose = current_pose
        pose.orientation =  orientation
        pose.position.x += data.dx
        pose.position.y += data.dy
        dz = np.clip(pose.position.z, 0.035,0.05)  # correct for drift
        pose.position.z = dz
        # rospy.loginfo("Updated Pose:\n%s", pose)

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        try:
            resp = self.iksvc(ikreq)
            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("Response Message:\n%s", resp)
                self.desired_theta = limb_joints
            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])
                resp = self.reset_sawyer_env()

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

    def update_velocities(self):
        joint_velocities = dict()
        delta_theta_raw = dict()

        rate=rospy.Rate(20)
        while not rospy.is_shutdown():
            if self.reset_arm == False:
                current_theta = self.joint_angles()

                for name in self.joint_names:
                    delta_theta_raw[name] = copy(self.desired_theta[name]) - current_theta[name]
                    self.delta_theta[name] = copy(self.alpha)*copy(self.delta_theta[name]) + (1-copy(self.alpha))*delta_theta_raw[name]
                    joint_velocities[name] = copy(self.c)*self.delta_theta[name]

                # rospy.loginfo("New Velocities: %s", joint_velocities)
                # rospy.loginfo("------------")
                self.set_joint_velocities(joint_velocities)
            rate.sleep()

    def reset(self,req):
        self.reset_arm = True
        # move up
        vertical_joints = self.move_up()
        self._pub_speed_ratio.publish(Float64(0.1))
        self.set_joint_positions(vertical_joints)
        time.sleep(2)

        # move to home
        self._pub_speed_ratio.publish(Float64(0.2))
        self.set_joint_positions(copy(self.home_joints))
        time.sleep(2)

        # reset parameters
        self.delta_theta = copy(self.reset_theta)
        self.desired_theta = copy(self.home_joints)
        rospy.loginfo("Reset Pose")

        self.reset_arm = False
        return TriggerResponse(success=True,
                               message="Done callback complete")

    def move_up(self):
        # solve inverse kinematics
        ikreq = SolvePositionIKRequest()

        current_pose = self.tip_state(self.tip_name).pose # get current state

        pose = current_pose
        pose.position.z += 0.06

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        limb_joints = copy(self.home_joints)
        try:
            resp = self.iksvc(ikreq)

            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("Response Message:\n%s", resp)
                self.desired_theta = limb_joints
            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

        return limb_joints

def main():
    rospy.init_node('ik_move')
    my_pose = go_to_pose()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
