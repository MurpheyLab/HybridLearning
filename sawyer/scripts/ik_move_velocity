#! /usr/bin/env python

# based on Rethink Robotics go_to_cartesian_pose.py
# Copyright (c) 2016-2018, Rethink Robotics Inc.

"""
Move the robot arm to the new position relative to the prior position specified
in the topic /puck/relative_move.

Call using:
$ rosrun sawyer ik_move

Publish position commmands using:
$ rostopic pub /puck/pose sawyer/RelativeMove "dx: 0.1
dy: 0."
"""
# general
import numpy as np
import time
from copy import copy, deepcopy
import warnings

# ros
import rospy
from geometry_msgs.msg import PoseStamped, Pose, Quaternion
from std_msgs.msg import Header, Float64
from sensor_msgs.msg import JointState
from std_srvs.srv import Trigger, TriggerResponse
from tf_conversions import transformations # , posemath # for relative pose movements...

# sawyer
from intera_core_msgs.srv import SolvePositionIK, SolvePositionIKRequest
from intera_core_msgs.msg import JointCommand, EndpointState,EndpointStates, CollisionDetectionState
from sawyer.msg import RelativeMove
# from intera_interface import Limb
from intera_interface import RobotParams, settings
import intera_dataflow

# pykdl
from sawyer_pykdl import sawyer_kinematics

class go_to_pose(object):
    def __init__(self):
        # set up ik solver
        limb = "right"
        self.tip_name = "right_hand"
        ns = "ExternalTools/" + limb + "/PositionKinematicsNode/IKService"
        self.iksvc = rospy.ServiceProxy(ns, SolvePositionIK)
        rospy.wait_for_service(ns, 5.0)

        # set up py_kdl
        self.py_kdl = sawyer_kinematics(limb)

        # set up sawyer (ijn place of limb class)
        ns_cmd = '/robot/limb/' + limb + '/'
        params = RobotParams()
        self.joint_names = params.get_joint_names(limb)
        self._joint_angle = dict()
        self._joint_velocity = dict()
        self._joint_effort = dict()
        self._joint_names = self.joint_names
        self._tip_states = None
        self._collision_state = False

        self._pub_speed_ratio = rospy.Publisher(ns_cmd + 'set_speed_ratio', Float64, latch=True, queue_size=1)
        self._command_msg = JointCommand()
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            self._pub_joint_cmd = rospy.Publisher(ns_cmd + 'joint_command',JointCommand,tcp_nodelay=True,queue_size=1)
        self._pub_joint_cmd_timeout = rospy.Publisher(ns_cmd + 'joint_command_timeout',Float64,latch=True,queue_size=1)
        _joint_state_sub = rospy.Subscriber('robot/joint_states',JointState,self._on_joint_states,queue_size=1,tcp_nodelay=True)
        _tip_states_sub = rospy.Subscriber(ns_cmd + 'tip_states',EndpointStates,self._on_tip_states,queue_size=1,tcp_nodelay=True)
        _collision_state_sub = rospy.Subscriber(ns_cmd + 'collision_detection_state',CollisionDetectionState,self._on_collision_state,queue_size=1,tcp_nodelay=True)

        # setup custom ros
        rospy.Service('/puck/reset', Trigger, self.reset)
        self.reset_sawyer_env = rospy.ServiceProxy('/puck/done', Trigger)

        # set up controller
        self.c = 0.5
        self.alpha = 0.8 # [0,1]
        self.reset_theta = dict()
        for name in self.joint_names:
            self.reset_theta[name] = 0.0
        self.delta_theta = deepcopy(self.reset_theta)

        # initalize home configuration
        home_orientation = Quaternion(0, 1, 0, 0)
        quaternion = (home_orientation.x, home_orientation.y,
                      home_orientation.z, home_orientation.w)
        self.euler = transformations.euler_from_quaternion(quaternion)
        self.reset_arm = False

        # home_pose = [-0.2, -0.6, 0.0, 1.9, 0.0, 0.3, 1.571]; # straight
        # home_pose = [-0.24649609375, -0.5411318359375, -0.3039619140625, 1.901158203125, 0.8013974609375, 0.36883203125, -0.1368642578125] # diagonal
        # home_pose = [-0.271728515625, -0.5496796875, -0.2440283203125, 1.94983984375, 0.7148427734375, 0.308125, -0.38069921875] # diagonal
        home_pose = [ 0.053275390625, -0.3608935546875, -0.439890625, 1.6846865234375, 1.010955078125, 0.504203125, -0.299798828125] # middle

        self.home_joints = dict(zip(self.joint_names, home_pose))

        # wait for first response to joint subscriber
        self.got_joints = False
        while (self.got_joints == False):
            # print('waiting')
            time.sleep(0.2)
        self.desired_theta_dot = deepcopy(self.reset_theta)

        self.raw_command = RelativeMove()
        self.filtered_command = RelativeMove()
        rospy.Subscriber('/puck/relative_move',RelativeMove,self.raw_command_callback)
        self.update_velocities()

    '''
    from limb class
    '''
    def _on_joint_states(self, msg):
        self.got_joints = True
        for idx, name in enumerate(msg.name):
            if name in self._joint_names:
                self._joint_angle[name] = msg.position[idx]
                self._joint_velocity[name] = msg.velocity[idx]
                self._joint_effort[name] = msg.effort[idx]

    def joint_angles(self):
        return deepcopy(self._joint_angle)

    def _on_tip_states(self, msg):
        self._tip_states = deepcopy(msg)

    def tip_state(self, tip_name):
        try:
            return deepcopy(self._tip_states.states[self._tip_states.names.index(tip_name)])
        except ValueError:
            return None

    def _on_collision_state(self, msg):
        if self._collision_state != msg.collision_state:
            self._collision_state = msg.collision_state

    def has_collided(self):
        return self._collision_state

    def set_joint_positions(self, positions):
        self._command_msg.names = positions.keys()
        self._command_msg.position = positions.values()
        self._command_msg.mode = JointCommand.POSITION_MODE
        self._command_msg.header.stamp = rospy.Time.now()
        self._pub_joint_cmd.publish(self._command_msg)

    def move_to_joint_positions(self, positions, timeout=15.0,
                                threshold=settings.JOINT_ANGLE_TOLERANCE,
                                test=None):
        cmd = self.joint_angles()

        def genf(joint, angle):
            def joint_diff():
                return abs(angle - self._joint_angle[joint])
            return joint_diff

        diffs = [genf(j, a) for j, a in positions.items() if
                 j in self._joint_angle]
        fail_msg = "limb failed to reach commanded joint positions."
        def test_collision():
            if self.has_collided():
                rospy.logerr(' '.join(["Collision detected.", fail_msg]))
                return True
            return False
        self.set_joint_positions(positions)
        intera_dataflow.wait_for(
            test=lambda: test_collision() or \
                         (callable(test) and test() == True) or \
                         (all(diff() < threshold for diff in diffs)),
            timeout=timeout,
            timeout_msg=fail_msg,
            rate=100,
            raise_on_error=False,
            body=lambda: self.set_joint_positions(positions)
            )

    def set_joint_velocities(self, velocities):
        self._command_msg.names = velocities.keys()
        self._command_msg.velocity = velocities.values()
        self._command_msg.mode = JointCommand.VELOCITY_MODE
        self._command_msg.header.stamp = rospy.Time.now()
        self._pub_joint_cmd.publish(self._command_msg)

    def set_joint_torques(self, torques):
        self._command_msg.names = torques.keys()
        self._command_msg.effort = torques.values()
        self._command_msg.mode = JointCommand.TORQUE_MODE
        self._command_msg.header.stamp = rospy.Time.now()
        self._pub_joint_cmd.publish(self._command_msg)

    '''
    custom
    '''

    # def normalize_angle(self, angle):
    #     if (angle > np.pi/2):
    #         angle -= np.pi
    #     elif (angle < -np.pi/2):
    #         angle += np.pi
    #     angle_new = np.clip(angle,-np.pi/4,np.pi/4)  # keep april tags in view
    #     return angle_new

    def raw_command_callback(self,_data):
        self.raw_command = _data

    def ee_vel_to_joint_vel(self,_data):
        # current_pose = self.joint_angles() # get current state
        # print(current_pose.values())
        # calculate jacobian_pseudo_inverse
        data = self.clip_velocities(_data)

        jacobian_ps = self.py_kdl.jacobian_pseudo_inverse(joint_values=None)
        # print(jacobian_ps)

        xdot = np.zeros(6)
        xdot[0] = data.dx
        xdot[1] = data.dy

        desired_theta_dot = np.matmul(jacobian_ps,xdot)

        for i in range(len(self.joint_names)):
            self.desired_theta_dot[self.joint_names[i]] = desired_theta_dot[0,i]

        # print(self.desired_theta_dot)


    def update_velocities(self):
        delta_theta_raw = dict()
        joint_velocities = dict()

        rate=rospy.Rate(5)
        while not rospy.is_shutdown():
            if self.reset_arm == True:
                # move up
                vertical_joints = self.move_up()
                self._pub_speed_ratio.publish(Float64(0.1))
                self.move_to_joint_positions(vertical_joints)
                time.sleep(2)

                # move to home
                self._pub_speed_ratio.publish(Float64(0.2))
                self.move_to_joint_positions(copy(self.home_joints))
                time.sleep(2)

                # reset parameters
                # self.delta_theta = deepcopy(self.reset_theta)
                self.desired_theta_dot = deepcopy(self.reset_theta)  # copy(self.home_joints)
                rospy.loginfo("Reset Pose")

                self.reset_arm = False
                self.raw_command = RelativeMove()
                self.filtered_command = RelativeMove()

            self.filtered_command.dx = self.alpha*self.filtered_command.dx+(1-self.alpha)*self.raw_command.dx
            self.filtered_command.dy = self.alpha*self.filtered_command.dy+(1-self.alpha)*self.raw_command.dy
            self.ee_vel_to_joint_vel(self.filtered_command)
            self.set_joint_velocities(self.desired_theta_dot)
            rate.sleep()

    def reset(self,req):
        self.reset_arm = True
        while (self.reset_arm == True):
            time.sleep(0.1)
        return TriggerResponse(success=True,
                               message="Done callback complete")

    def clip_velocities(self,action):
        max_x = 0.75
        min_x = 0.5 # 0.45
        max_y = 0.25 #0.3
        min_y = -0.2 #-0.25

        if (self.tip_state(self.tip_name).pose.position.x > max_x):
            action.dx = np.clip(action.dx, -1,0)
        elif (self.tip_state(self.tip_name).pose.position.x < min_x):
            action.dx = np.clip(action.dx, 0,1)
        if (self.tip_state(self.tip_name).pose.position.y > max_y):
            action.dy = np.clip(action.dy, -1,0)
        elif(self.tip_state(self.tip_name).pose.position.y < min_y):
            action.dy = np.clip(action.dy, 0,1)

        return action

    def move_up(self):
        # solve inverse kinematics
        ikreq = SolvePositionIKRequest()

        current_pose = self.tip_state(self.tip_name).pose # get current state

        pose = current_pose
        pose.position.z += 0.06

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        limb_joints = copy(self.home_joints)
        try:
            resp = self.iksvc(ikreq)

            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("Response Message:\n%s", resp)
                self.desired_theta = limb_joints
            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

        return limb_joints

def main():
    rospy.init_node('ik_move')
    my_pose = go_to_pose()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
