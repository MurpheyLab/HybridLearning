#! /usr/bin/env python

# based on Rethink Robotics go_to_cartesian_pose.py
# Copyright (c) 2016-2018, Rethink Robotics Inc.

"""
Move the robot arm to the new position relative to the prior position specified
in the topic /puck/relative_move.

Call using:
$ rosrun sawyer ik_move

Publish position commmands using:
$ rostopic pub /puck/pose sawyer/Move "dx: 0.1
dy: 0.
linear_speed: 0.5"
"""
import rospy
import numpy as np

# messages
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from std_msgs.msg import Header, UInt16
from sensor_msgs.msg import JointState

# services
from std_srvs.srv import Empty, EmptyResponse

# sawyer
from intera_core_msgs.srv import SolvePositionIK, SolvePositionIKRequest
from intera_core_msgs.msg import JointCommand
from sawyer.msg import RelativeMove
from intera_interface import Limb

# tf
import PyKDL # for relative pose movements...
from tf_conversions import posemath, transformations # for relative pose movements...
import time

class go_to_pose(object):
    def __init__(self):
        # set up ik solver
        limb = "right"
        ns = "ExternalTools/" + limb + "/PositionKinematicsNode/IKService"
        self.iksvc = rospy.ServiceProxy(ns, SolvePositionIK)
        rospy.wait_for_service(ns, 5.0)

        # set up sawyer
        self.limb = Limb()
        self.in_tip_frame = False
        self.tip_name = 'right_hand'
        self.endpoint_state = self.limb.tip_state(self.tip_name)
        if self.endpoint_state is None:
            rospy.logerr('Endpoint state not found with tip name %s', self.tip_name)

        # setup ros
        s = rospy.Service('/puck/reset', Empty, self.reset)
        rospy.Subscriber('/puck/relative_move',RelativeMove,self.pose_callback)

        # set up controller
        self.c = 0.5
        self.alpha = 0.8 # [0,1]
        self.joint_names = self.limb.joint_names()
        self.delta_theta = dict()
        for name in self.joint_names:
            self.delta_theta[name] = 0.0

        # initalize with current joint angles
        self.desired_theta = self.limb.joint_angles()
        self.home_orientation = Quaternion(0, 1, 0, 0)
        self.last_theta = 0

        self.reset_arm = 0

        home_pose = [-0.2, -0.6, 0.0, 1.9, 0.0, 0.3, 1.571];
        self.home_joints = dict(zip(self.joint_names, home_pose))
        self.limb.set_joint_position_speed(speed=0.6)
        self.limb.set_joint_positions(self.home_joints)

        self.update_velocities()

    def pose_callback(self,data):

        # solve inverse kinematics
        ikreq = SolvePositionIKRequest()

        current_pose = Limb().tip_state(self.tip_name).pose # get current state
        rospy.loginfo("Current Pose:\n%s", current_pose)

        # relative move
        # create kdl frame from relative pose
        theta = np.arctan2(data.dy, data.dx)

        # rot = PyKDL.Rotation.RPY(0.0,0.0,theta) # roll, pitch, yaw
        # trans = PyKDL.Vector(data.dx, data.dy, 0.0) # x,y,z
        # f2 = PyKDL.Frame(rot, trans)
        # rospy.loginfo("KDL:\n%s", f2)
        #
        # # and convert the result back to a pose message
        # if self.in_tip_frame: # end effector frame
        #     pose = posemath.toMsg(posemath.fromMsg(current_pose) * f2)
        # else: # base frame
        #     pose = posemath.toMsg(f2 * posemath.fromMsg(current_pose))

        if (data.dy == 0):
            orientation = self.home_orientation
        elif (abs(theta) == abs(self.last_theta)):
            orientation = current_pose.orientation
        else:
            quaternion = (self.home_orientation.x, self.home_orientation.y,
                          self.home_orientation.z, self.home_orientation.w)
            euler = transformations.euler_from_quaternion(quaternion)

            orientation = Quaternion(*transformations.quaternion_from_euler(euler[0], euler[1], euler[2]+theta))

            # rospy.loginfo("theta:\n%s", theta)
            # rospy.loginfo("home orientation?:\n%s", euler)
            # rospy.loginfo("orientation?:\n%s", orientation)

        self.last_theta = theta

        pose = current_pose
        pose.orientation =  orientation
        pose.position.x += data.dx
        pose.position.y += data.dy
        dz = np.clip(pose.position.z, 0.022,.04)  # correct for drift
        pose.position.z = dz
        rospy.loginfo("Updated Pose:\n%s", pose)

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        try:
            resp = self.iksvc(ikreq)

            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("Response Message:\n%s", resp)
                self.desired_theta = limb_joints
            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

    def update_velocities(self):
        joint_velocities = dict()
        delta_theta_raw = dict()

        rate=rospy.Rate(50)
        while not rospy.is_shutdown():
            if self.reset_arm == 0:
                current_theta = self.limb.joint_angles()

                for name in self.joint_names:
                    delta_theta_raw[name] = self.desired_theta[name] - current_theta[name]
                    self.delta_theta[name] = self.alpha*self.delta_theta[name] + (1-self.alpha)*delta_theta_raw[name]
                    joint_velocities[name] = self.c*self.delta_theta[name]
                    # joint_velocities[name] = self.c*delta_theta_raw[name]

                # rospy.loginfo("New Velocities: %s", joint_velocities)
                # rospy.loginfo("------------")
                self.limb.set_joint_velocities(joint_velocities)
            rate.sleep()

    def reset(self,req):
        self.reset_arm = 1

        # change to position mode
        # move up
        vertical_joints = self.move_up()
        self.limb.set_joint_position_speed(speed=0.1)
        self.limb.move_to_joint_positions(vertical_joints, timeout=15.0)
        time.sleep(2)

        # reset parameters
        for name in self.joint_names:
            self.delta_theta[name] = 0.0
        self.desired_theta = self.home_joints
        self.last_theta = 0

        # move to home
        self.limb.set_joint_position_speed(speed=0.2)
        self.limb.move_to_joint_positions(self.home_joints, timeout=15.0)
        rospy.loginfo("Reset Pose")
        time.sleep(2)
        self.reset_arm = 0
        return EmptyResponse()

    def move_up(self):
        # solve inverse kinematics
        ikreq = SolvePositionIKRequest()

        current_pose = Limb().tip_state(self.tip_name).pose # get current state

        pose = current_pose
        pose.position.z += 0.05

        # create stamped pose with updated pose
        poseStamped = PoseStamped()
        poseStamped.header = Header(stamp=rospy.Time.now(), frame_id='base')
        poseStamped.pose = pose

        # Add desired pose for inverse kinematics
        ikreq.pose_stamp.append(poseStamped)
        ikreq.tip_names.append('right_hand') # for each pose in IK

        try:
            resp = self.iksvc(ikreq)

            # Check if result valid, and type of seed ultimately used to get solution
            if (resp.result_type[0] > 0):
                limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
                # rospy.loginfo("Response Message:\n%s", resp)
                self.desired_theta = limb_joints
            else:
                rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
                rospy.logerr("Result Error %d", resp.result_type[0])

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.logerr("Service call failed: %s" % (e,))

        return limb_joints


def main():
    rospy.init_node('ik_move')
    my_pose = go_to_pose()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
